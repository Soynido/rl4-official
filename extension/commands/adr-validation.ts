/**
 * ADR Validation Commands - Phase E2 Final
 * 
 * VS Code commands for human validation of auto-proposed ADRs
 * - Review Pending ADRs
 * - Accept/Reject Proposals
 * - Track validation history
 */

import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';

interface ProposedADR {
    id: string;
    title: string;
    status: 'proposed' | 'accepted' | 'deprecated' | 'superseded';
    createdAt: string;
    modifiedAt: string;
    author: string;
    context: string;
    decision: string;
    consequences: string;
    tags: string[];
    autoGenerated: boolean;
    forecast_source: string;
    requires_human_validation: boolean;
    proposedAt: string;
    validationStatus: 'pending' | 'accepted' | 'rejected';
    validationNotes?: string;
    confidence: number;
}

interface ValidationHistory {
    adr_id: string;
    action: 'accepted' | 'rejected';
    timestamp: string;
    validator: string;
    notes?: string;
    confidence: number;
}

export class ADRValidationCommands {
    private workspaceRoot: string;
    private adrDir: string;
    private ledgerPath: string;

    constructor(workspaceRoot: string) {
        this.workspaceRoot = workspaceRoot;
        this.adrDir = path.join(workspaceRoot, '.reasoning_rl4', 'adrs', 'auto');
        this.ledgerPath = path.join(workspaceRoot, '.reasoning_rl4', 'ledger', 'adr_validations.jsonl');
    }

    /**
     * Register all ADR validation commands
     */
    public static registerCommands(context: vscode.ExtensionContext, workspaceRoot: string): void {
        const commands = new ADRValidationCommands(workspaceRoot);

        context.subscriptions.push(
            vscode.commands.registerCommand('reasoning.adr.reviewPending', () => commands.reviewPending()),
            vscode.commands.registerCommand('reasoning.adr.acceptProposal', () => commands.acceptProposal()),
            vscode.commands.registerCommand('reasoning.adr.rejectProposal', () => commands.rejectProposal())
        );
    }

    /**
     * Command: Review Pending ADRs
     * Shows a QuickPick with all pending ADR proposals
     */
    private async reviewPending(): Promise<void> {
        const pendingADRs = await this.loadPendingADRs();

        if (pendingADRs.length === 0) {
            vscode.window.showInformationMessage('‚úÖ No pending ADR proposals to review.');
            return;
        }

        // Create QuickPick items
        const items: vscode.QuickPickItem[] = pendingADRs.map(adr => ({
            label: `$(symbol-event) ${adr.title.substring(0, 80)}${adr.title.length > 80 ? '...' : ''}`,
            description: `Confidence: ${(adr.confidence * 100).toFixed(0)}%`,
            detail: `ID: ${adr.id} | Created: ${new Date(adr.proposedAt).toLocaleDateString()}`,
            adr: adr as any
        }));

        // Show QuickPick
        const selected = await vscode.window.showQuickPick(items, {
            placeHolder: `üìã Review ${pendingADRs.length} pending ADR proposal(s)`,
            matchOnDescription: true,
            matchOnDetail: true
        });

        if (selected) {
            await this.showADRDetails((selected as any).adr);
        }
    }

    /**
     * Command: Accept ADR Proposal
     * Accept a specific ADR and mark as validated
     */
    private async acceptProposal(): Promise<void> {
        const pendingADRs = await this.loadPendingADRs();

        if (pendingADRs.length === 0) {
            vscode.window.showInformationMessage('‚úÖ No pending ADR proposals to accept.');
            return;
        }

        // Create QuickPick items
        const items: vscode.QuickPickItem[] = pendingADRs.map(adr => ({
            label: `$(check) ${adr.title.substring(0, 80)}`,
            description: `${(adr.confidence * 100).toFixed(0)}%`,
            detail: `${adr.id}`,
            adr: adr as any
        }));

        // Show QuickPick
        const selected = await vscode.window.showQuickPick(items, {
            placeHolder: '‚úÖ Select ADR to accept',
            matchOnDescription: true
        });

        if (selected) {
            const adr = (selected as any).adr;
            
            // Ask for optional notes
            const notes = await vscode.window.showInputBox({
                prompt: 'Optional: Add validation notes',
                placeHolder: 'Why was this ADR accepted?'
            });

            await this.validateADR(adr, 'accepted', notes);
            vscode.window.showInformationMessage(`‚úÖ ADR accepted: "${adr.title.substring(0, 50)}..."`);
        }
    }

    /**
     * Command: Reject ADR Proposal
     * Reject a specific ADR with reason
     */
    private async rejectProposal(): Promise<void> {
        const pendingADRs = await this.loadPendingADRs();

        if (pendingADRs.length === 0) {
            vscode.window.showInformationMessage('‚úÖ No pending ADR proposals to reject.');
            return;
        }

        // Create QuickPick items
        const items: vscode.QuickPickItem[] = pendingADRs.map(adr => ({
            label: `$(x) ${adr.title.substring(0, 80)}`,
            description: `${(adr.confidence * 100).toFixed(0)}%`,
            detail: `${adr.id}`,
            adr: adr as any
        }));

        // Show QuickPick
        const selected = await vscode.window.showQuickPick(items, {
            placeHolder: '‚ùå Select ADR to reject',
            matchOnDescription: true
        });

        if (selected) {
            const adr = (selected as any).adr;
            
            // Ask for rejection reason
            const notes = await vscode.window.showInputBox({
                prompt: 'Required: Why is this ADR being rejected?',
                placeHolder: 'Reason for rejection...',
                validateInput: (value) => {
                    return value.trim().length === 0 ? 'Rejection reason is required' : null;
                }
            });

            if (notes) {
                await this.validateADR(adr, 'rejected', notes);
                vscode.window.showInformationMessage(`‚ùå ADR rejected: "${adr.title.substring(0, 50)}..."`);
            }
        }
    }

    /**
     * Show ADR details in a new document
     */
    private async showADRDetails(adr: ProposedADR): Promise<void> {
        const content = this.formatADRForDisplay(adr);
        
        const doc = await vscode.workspace.openTextDocument({
            content,
            language: 'markdown'
        });
        
        await vscode.window.showTextDocument(doc, {
            preview: true,
            viewColumn: vscode.ViewColumn.Beside
        });

        // Ask for action
        const action = await vscode.window.showQuickPick(
            [
                { label: '‚úÖ Accept this ADR', value: 'accept' },
                { label: '‚ùå Reject this ADR', value: 'reject' },
                { label: 'üëÄ Review later', value: 'skip' }
            ],
            { placeHolder: 'What action would you like to take?' }
        );

        if (action) {
            if (action.value === 'accept') {
                const notes = await vscode.window.showInputBox({
                    prompt: 'Optional: Add validation notes'
                });
                await this.validateADR(adr, 'accepted', notes);
                vscode.window.showInformationMessage(`‚úÖ ADR accepted!`);
            } else if (action.value === 'reject') {
                const notes = await vscode.window.showInputBox({
                    prompt: 'Required: Why is this ADR being rejected?',
                    validateInput: (value) => value.trim().length === 0 ? 'Reason required' : null
                });
                if (notes) {
                    await this.validateADR(adr, 'rejected', notes);
                    vscode.window.showInformationMessage(`‚ùå ADR rejected!`);
                }
            }
        }
    }

    /**
     * Format ADR for display in Markdown
     */
    private formatADRForDisplay(adr: ProposedADR): string {
        return `# ADR Proposal Review

## ${adr.title}

**ID**: \`${adr.id}\`  
**Status**: ${adr.validationStatus} (${adr.status})  
**Confidence**: ${(adr.confidence * 100).toFixed(0)}%  
**Proposed**: ${new Date(adr.proposedAt).toLocaleString()}  
**Forecast Source**: \`${adr.forecast_source}\`

---

## üìã Context

${adr.context}

---

## üéØ Decision

${adr.decision}

---

## üìä Consequences

${adr.consequences}

---

## üè∑Ô∏è Tags

${adr.tags.map(t => `\`${t}\``).join(', ')}

---

## ‚öôÔ∏è Metadata

- **Auto-Generated**: ${adr.autoGenerated ? 'Yes' : 'No'}
- **Requires Validation**: ${adr.requires_human_validation ? 'Yes' : 'No'}
- **Author**: ${adr.author}
- **Created**: ${new Date(adr.createdAt).toLocaleString()}
- **Modified**: ${new Date(adr.modifiedAt).toLocaleString()}

---

**Actions**:
- ‚úÖ Accept this proposal if it represents a valid architectural decision
- ‚ùå Reject if it's redundant, incorrect, or not actionable
- üëÄ Review later if you need more context
`;
    }

    /**
     * Validate an ADR (accept or reject)
     */
    private async validateADR(adr: ProposedADR, action: 'accepted' | 'rejected', notes?: string): Promise<void> {
        // Update ADR file
        adr.validationStatus = action;
        adr.validationNotes = notes;
        adr.modifiedAt = new Date().toISOString();

        if (action === 'accepted') {
            adr.status = 'accepted';
        }

        const adrPath = path.join(this.adrDir, `${adr.id}.json`);
        fs.writeFileSync(adrPath, JSON.stringify(adr, null, 2));

        // Track in validation ledger
        await this.trackValidation({
            adr_id: adr.id,
            action,
            timestamp: new Date().toISOString(),
            validator: 'human',
            notes,
            confidence: adr.confidence
        });

        // Regenerate proposals index
        await this.regenerateProposalIndex();
    }

    /**
     * Track validation in append-only ledger
     */
    private async trackValidation(validation: ValidationHistory): Promise<void> {
        // Ensure ledger directory exists
        const ledgerDir = path.dirname(this.ledgerPath);
        if (!fs.existsSync(ledgerDir)) {
            fs.mkdirSync(ledgerDir, { recursive: true });
        }

        // Append to ledger
        const line = JSON.stringify(validation) + '\n';
        fs.appendFileSync(this.ledgerPath, line);
    }

    /**
     * Load all pending ADRs
     */
    private async loadPendingADRs(): Promise<ProposedADR[]> {
        if (!fs.existsSync(this.adrDir)) {
            return [];
        }

        const files = fs.readdirSync(this.adrDir)
            .filter(f => f.endsWith('.json') && f !== 'proposals.index.json');

        const pendingADRs: ProposedADR[] = [];

        for (const file of files) {
            try {
                const filePath = path.join(this.adrDir, file);
                const data = fs.readFileSync(filePath, 'utf-8');
                const adr = JSON.parse(data) as ProposedADR;

                if (adr.validationStatus === 'pending') {
                    pendingADRs.push(adr);
                }
            } catch (error) {
                console.error(`Error loading ADR ${file}:`, error);
            }
        }

        // Sort by confidence (highest first)
        return pendingADRs.sort((a, b) => b.confidence - a.confidence);
    }

    /**
     * Regenerate proposals index after validation
     */
    private async regenerateProposalIndex(): Promise<void> {
        if (!fs.existsSync(this.adrDir)) {
            return;
        }

        const files = fs.readdirSync(this.adrDir)
            .filter(f => f.endsWith('.json') && f !== 'proposals.index.json');

        const proposals: ProposedADR[] = [];

        for (const file of files) {
            try {
                const filePath = path.join(this.adrDir, file);
                const data = fs.readFileSync(filePath, 'utf-8');
                proposals.push(JSON.parse(data));
            } catch {}
        }

        const pending = proposals.filter(p => p.validationStatus === 'pending').map(p => p.id);
        const accepted = proposals.filter(p => p.validationStatus === 'accepted').map(p => p.id);
        const rejected = proposals.filter(p => p.validationStatus === 'rejected').map(p => p.id);

        const index = {
            generated_at: new Date().toISOString(),
            total_proposals: proposals.length,
            pending,
            accepted,
            rejected,
            proposals: proposals.map(p => ({
                id: p.id,
                title: p.title,
                confidence: p.confidence,
                status: p.validationStatus,
                forecast_source: p.forecast_source,
                proposedAt: p.proposedAt
            }))
        };

        const indexPath = path.join(this.adrDir, 'proposals.index.json');
        fs.writeFileSync(indexPath, JSON.stringify(index, null, 2));
    }
}

