/**
 * ADR Generator V2 - Level 7
 * 
 * Transforms forecasts into actionable ADR proposals
 * Requires human validation before acceptance
 */

import * as fs from 'fs';
import * as path from 'path';
import { Forecast, ADR } from './types';

interface ProposedADR extends ADR {
    autoGenerated: boolean;               // True for auto-generated ADRs
    forecast_source: string;              // ID of the forecast that generated this
    requires_human_validation: boolean;   // Always true for generated ADRs
    proposedAt: string;                   // When the proposal was generated
    validationStatus: 'pending' | 'accepted' | 'rejected';
    validationNotes?: string;
    confidence: number;                    // Confidence from forecast
}

interface ProposalIndex {
    generated_at: string;
    total_proposals: number;
    pending: string[];
    accepted: string[];
    rejected: string[];
    proposals: {
        id: string;
        title: string;
        confidence: number;
        status: 'pending' | 'accepted' | 'rejected';
        forecast_source: string;
        proposedAt: string;
    }[];
}

export class ADRGeneratorV2 {
    private workspaceRoot: string;
    private forecastsPath: string;
    private patternsPath: string;
    private autoAdrDir: string;
    private proposalIndexPath: string;

    constructor(workspaceRoot: string) {
        this.workspaceRoot = workspaceRoot;
        this.forecastsPath = path.join(workspaceRoot, '.reasoning_rl4', 'forecasts.json');
        this.patternsPath = path.join(workspaceRoot, '.reasoning_rl4', 'patterns.json');
        this.autoAdrDir = path.join(workspaceRoot, '.reasoning_rl4', 'adrs', 'auto');
        this.proposalIndexPath = path.join(this.autoAdrDir, 'proposals.index.json');
    }

    /**
     * Generate ADR proposals from forecasts
     */
    public async generateProposals(): Promise<ProposedADR[]> {
        console.log('üß© ADRGeneratorV2: Starting ADR proposal generation...');

        // Ensure auto ADR directory exists
        if (!fs.existsSync(this.autoAdrDir)) {
            fs.mkdirSync(this.autoAdrDir, { recursive: true });
        }

        // Load forecasts
        const forecasts = await this.loadForecasts();
        if (!forecasts || forecasts.length === 0) {
            console.log('üß© No forecasts available for ADR generation');
            return [];
        }

        // Load patterns for context
        const patterns = await this.loadPatterns();

        console.log(`üìä Processing ${forecasts.length} forecasts...`);

        const proposals: ProposedADR[] = [];

        for (const forecast of forecasts) {
            // Only generate proposals for ADR_Proposal forecast types
            if (forecast.decision_type !== 'ADR_Proposal') continue;

            // Find related pattern for additional context
            const relatedPattern = patterns?.find(
                p => forecast.related_patterns?.includes(p.id)
            );

            // Create ADR proposal
            const proposal = this.createProposal(forecast, relatedPattern);
            
            // Phase E2.4: Save with deduplication
            const wasSaved = !(await this.isDuplicate(proposal));
            if (wasSaved) {
                await this.saveProposal(proposal);
                proposals.push(proposal); // Only add to list if actually saved
            }
        }

        // Generate proposal index
        await this.generateProposalIndex(proposals);

        console.log(`‚úÖ ADR Synthesizer: ${proposals.length} proposals generated (awaiting validation)`);

        return proposals;
    }

    /**
     * Create an ADR proposal from a forecast
     */
    private createProposal(forecast: Forecast, pattern?: any): ProposedADR {
        const proposalId = `adr-proposed-${Date.now()}-${Math.random().toString(36).substring(7)}`;
        const now = new Date().toISOString();

        // Build context from forecast rationale
        const context = this.buildContext(forecast, pattern);

        // Build decision from forecast
        const decision = `[AUTO-PROPOSED] ${forecast.predicted_decision}\n\nThis proposal was generated based on:\n${forecast.rationale.map(r => `- ${r}`).join('\n')}\n\nRequires human validation before acceptance.`;

        // Build consequences from pattern impact
        const consequences = pattern 
            ? `Expected impact: ${pattern.impact || 'Unknown'}\n\nPattern: ${pattern.pattern}\nConfidence: ${Math.round(pattern.confidence * 100)}%`
            : 'Impact analysis pending human review.';

        return {
            id: proposalId,
            title: forecast.predicted_decision,
            status: 'proposed',
            createdAt: now,
            modifiedAt: now,
            author: 'ADR Synthesizer V2 (Auto)',
            context,
            decision,
            consequences,
            tags: forecast.related_patterns || [],
            components: [],
            relatedADRs: [],
            evidenceIds: [],
            autoGenerated: true,
            forecast_source: forecast.forecast_id,
            requires_human_validation: true,
            proposedAt: now,
            validationStatus: 'pending',
            confidence: forecast.confidence,
            // Add estimated effort and urgency from forecast
            constraints: {
                timeline: forecast.suggested_timeframe || 'TBD'
            },
            risks: [{
                risk: `Proposed based on ${forecast.confidence * 100}% confidence forecast`,
                probability: forecast.urgency === 'high' ? 'high' : 'medium' as any,
                impact: 'medium' as any
            }]
        };
    }

    /**
     * Build context from forecast and pattern
     */
    private buildContext(forecast: Forecast, pattern?: any): string {
        let context = `This ADR was automatically proposed based on pattern analysis and forecast modeling.\n\n`;

        if (pattern) {
            context += `Pattern detected: "${pattern.pattern}"\n`;
            context += `Frequency: ${pattern.frequency} occurrences\n`;
            context += `Pattern confidence: ${Math.round(pattern.confidence * 100)}%\n\n`;
        }

        context += `Forecast confidence: ${Math.round(forecast.confidence * 100)}%\n`;
        context += `Suggested timeframe: ${forecast.suggested_timeframe}\n`;
        context += `Estimated effort: ${forecast.estimated_effort}\n\n`;
        context += `Rationale:\n${forecast.rationale.map(r => `- ${r}`).join('\n')}\n\n`;
        context += `‚ö†Ô∏è This proposal requires human validation before acceptance.`;

        return context;
    }

    /**
     * Generate stable hash for ADR deduplication
     * Uses only the title (predicted_decision) to avoid false duplicates from varying correlation scores
     */
    private generateADRHash(title: string): string {
        // Normalize: lowercase, remove special chars, collapse whitespace
        const normalized = title
            .toLowerCase()
            .replace(/[^a-z0-9\s]/g, '')
            .replace(/\s+/g, ' ')
            .trim();
        
        // Use crypto hash for better collision resistance
        const crypto = require('crypto');
        return crypto.createHash('sha256').update(normalized).digest('hex').substring(0, 16);
    }

    /**
     * Check if similar ADR already exists (improved deduplication)
     */
    private async isDuplicate(proposal: ProposedADR): Promise<boolean> {
        if (!fs.existsSync(this.autoAdrDir)) return false;
        
        const proposalHash = this.generateADRHash(proposal.title);
        
        // Load existing ADRs
        const files = fs.readdirSync(this.autoAdrDir).filter(f => f.endsWith('.json') && f !== 'proposals.index.json');
        
        for (const file of files) {
            try {
                const existing = JSON.parse(fs.readFileSync(path.join(this.autoAdrDir, file), 'utf-8'));
                const existingHash = this.generateADRHash(existing.title || '');
                
                // If hashes match, it's a duplicate
                if (proposalHash === existingHash) {
                    console.log(`üîí [Dedup] Skipping duplicate ADR: "${proposal.title.substring(0, 60)}..."`);
                    return true;
                }
            } catch {}
        }
        
        return false;
    }

    /**
     * Save individual proposal (with deduplication)
     */
    private async saveProposal(proposal: ProposedADR): Promise<void> {
        const filePath = path.join(this.autoAdrDir, `${proposal.id}.json`);
        fs.writeFileSync(filePath, JSON.stringify(proposal, null, 2));
    }

    /**
     * Generate proposal index
     */
    private async generateProposalIndex(proposals: ProposedADR[]): Promise<void> {
        const pending = proposals.filter(p => p.validationStatus === 'pending').map(p => p.id);
        const accepted = proposals.filter(p => p.validationStatus === 'accepted').map(p => p.id);
        const rejected = proposals.filter(p => p.validationStatus === 'rejected').map(p => p.id);

        const index: ProposalIndex = {
            generated_at: new Date().toISOString(),
            total_proposals: proposals.length,
            pending,
            accepted,
            rejected,
            proposals: proposals.map(p => ({
                id: p.id,
                title: p.title,
                confidence: p.confidence,
                status: p.validationStatus,
                forecast_source: p.forecast_source,
                proposedAt: p.proposedAt
            }))
        };

        fs.writeFileSync(this.proposalIndexPath, JSON.stringify(index, null, 2));
    }

    /**
     * Load forecasts
     */
    private async loadForecasts(): Promise<Forecast[]> {
        try {
            if (!fs.existsSync(this.forecastsPath)) {
                return [];
            }
            const data = fs.readFileSync(this.forecastsPath, 'utf8');
            return JSON.parse(data);
        } catch (error) {
            console.error('Error loading forecasts:', error);
            return [];
        }
    }

    /**
     * Load patterns
     */
    private async loadPatterns(): Promise<any[]> {
        try {
            if (!fs.existsSync(this.patternsPath)) {
                return [];
            }
            const data = fs.readFileSync(this.patternsPath, 'utf8');
            const parsed = JSON.parse(data);
            return parsed.patterns || [];
        } catch (error) {
            console.error('Error loading patterns:', error);
            return [];
        }
    }

    /**
     * Get all pending proposals
     */
    public async getPendingProposals(): Promise<ProposedADR[]> {
        if (!fs.existsSync(this.autoAdrDir)) {
            return [];
        }

        const files = fs.readdirSync(this.autoAdrDir)
            .filter(f => f.endsWith('.json') && f !== 'proposals.index.json');

        const proposals: ProposedADR[] = [];
        for (const file of files) {
            const filePath = path.join(this.autoAdrDir, file);
            const data = fs.readFileSync(filePath, 'utf8');
            const proposal = JSON.parse(data);
            if (proposal.validationStatus === 'pending') {
                proposals.push(proposal);
            }
        }

        return proposals;
    }

    /**
     * Validate a proposal (accept or reject)
     */
    public async validateProposal(
        proposalId: string, 
        status: 'accepted' | 'rejected',
        notes?: string
    ): Promise<void> {
        const filePath = path.join(this.autoAdrDir, `${proposalId}.json`);
        
        if (!fs.existsSync(filePath)) {
            throw new Error(`Proposal ${proposalId} not found`);
        }

        const data = fs.readFileSync(filePath, 'utf8');
        const proposal = JSON.parse(data) as ProposedADR;

        proposal.validationStatus = status;
        proposal.validationNotes = notes;
        proposal.modifiedAt = new Date().toISOString();

        if (status === 'accepted') {
            proposal.status = 'accepted';
        }

        fs.writeFileSync(filePath, JSON.stringify(proposal, null, 2));

        // Update index
        await this.refreshProposalIndex();
    }

    /**
     * Refresh proposal index after validation
     */
    private async refreshProposalIndex(): Promise<void> {
        if (!fs.existsSync(this.autoAdrDir)) {
            return;
        }

        const files = fs.readdirSync(this.autoAdrDir)
            .filter(f => f.endsWith('.json') && f !== 'proposals.index.json');

        const proposals: ProposedADR[] = [];
        for (const file of files) {
            const filePath = path.join(this.autoAdrDir, file);
            const data = fs.readFileSync(filePath, 'utf8');
            proposals.push(JSON.parse(data));
        }

        await this.generateProposalIndex(proposals);
    }
}
